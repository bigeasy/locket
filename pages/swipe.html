Locket is an implementation of LevelDB layered over evented b-trees (Strata), boasting durability(1), atomicity(2), and complete isolation(3). This is accomplished by keeping multiple trees - one 'primary' tree, and a queue any number of 'staging' trees.

Writes are particularly fast because every transaction is immediately written to a staging tree, and assigned a transaction ID. If that transaction is successful, Locket keeps track of that ID and guarantees[1] that the transaction will be saved. The oldest tree in the queue is merged into the primary tree at Locket's leisure while the newest tree collects transactions. There can be any number of trees in the queue, but unless there has been one or more crashes, there should never be more than two (or, if no merging is currently taking place, one). If a transaction is not successfully written to the newest staging tree, Locket does *not* keep track of the transaction ID and it is ignored during merging[2].

Records are sorted by key and then by transaction ID. This means that there can be more than one record with the same key across trees, and any read operation will retrieve only the newest record (the record with the highest transaction ID). Thus, reading before Locket has merged recent transactions will still retrieve the newest value for any given key. Reading *during* a write will ignore any current writes; that is, you cannot access a value updated by a given transaction until that entire transaction is written[3].
